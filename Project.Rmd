---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
library(igraph)
```

Networks:

```{r}
set.seed(42)
n <- 1000
ER <- sample_gnm(n=n, m=1000)
BA <- barabasi.game(n, 2, directed = FALSE)
WS <- sample_smallworld(dim=1,size=n, nei=1,p=0.05)
complete_graph <- make_full_graph(n)
tree <- make_tree(n, children = 1, mode = "undirected")
```

Real networks:

#GR-QC
```{r}
edge_list <- read.csv("data/CA-GrQc.txt", sep="\t", header=FALSE, skip=4, col.names=c("FromNodeId", "ToNodeId"))
G <- graph_from_data_frame(edge_list, directed=TRUE, vertices=NULL)
# Remove self-loops and multiple edges
GR_QC <- simplify(G, remove.multiple = TRUE, remove.loops = TRUE)
```

#HEP-TH
```{r}
edge_list <- read.csv("data/CA-HepTh.txt", sep="\t", header=FALSE, skip=4, col.names=c("FromNodeId", "ToNodeId"))
G <- graph_from_data_frame(edge_list, directed=TRUE, vertices=NULL)
# Remove self-loops and multiple edges
HEP_TH <- simplify(G, remove.multiple = TRUE, remove.loops = TRUE)
```

#Facebook
```{r}
edge_list <- read.csv("data/musae_facebook_edges.csv", sep=",", header=FALSE, skip=1, col.names=c("FromNodeId", "ToNodeId"))
G <- graph_from_data_frame(edge_list, directed=TRUE, vertices=NULL)
# Remove self-loops and multiple edges
Facebook <- simplify(G, remove.multiple = TRUE, remove.loops = TRUE)

```

#Deezer
```{r}
edge_list <- read.csv("data/deezer_europe_edges.csv", sep=",", header=FALSE, skip=1, col.names=c("FromNodeId", "ToNodeId"))
G <- graph_from_data_frame(edge_list, directed=TRUE, vertices=NULL)
# Remove self-loops and multiple edges
Deezer <- simplify(G, remove.multiple = TRUE, remove.loops = TRUE)
```

#EmailEnron
```{r}
edge_list <- read.csv("data/email-Enron.txt", sep="\t", header=FALSE, skip=4, col.names=c("FromNodeId", "ToNodeId"))
G <- graph_from_data_frame(edge_list, directed=TRUE, vertices=NULL)
# Remove self-loops and multiple edges
EmailEnron <- simplify(G, remove.multiple = TRUE, remove.loops = TRUE)
```


Parameters:

```{r}
p0 <- 0.05
beta <- 0.6
gamma <- 0.4
```

SIS model:

```{r}
# Function to simulate SIS model

SISsim <- function(G, beta, gamma, p0, max_steps = 100) {
  statuses <- numeric(vcount(G))
  statuses[sample(1:vcount(G), size = round(p0 * vcount(G)))] <- 1  # p0 fraction infected
  prop_infected <- numeric(max_steps)
  
  for (step in 1:max_steps) {
    for (node in 1:vcount(G)) {
      if (statuses[node] == 1) {
        neighbors <- neighbors(G, node)
        for (neighbor in neighbors) {
          # Get infected after contact (neighbors)
          if (statuses[neighbor] == 0 && runif(1) < beta) {
            statuses[neighbor] <- 1
          }
        }
      # Get recovered
      if (statuses[node] == 1 && runif(1) < gamma) {
      statuses[node] <- 0
      }
      }
    }
    prop_infected[step] <- sum(statuses) / vcount(G)
    
  }
  return(prop_infected[1:step])
}
```

#Plots of the SIS model

```{r}
sim_ER <- SISsim(ER, beta, gamma, p0)
sim_BA <- SISsim(BA, beta, gamma, p0)
sim_WS <- SISsim(WS, beta, gamma, p0)
sim_compl <- SISsim(complete_graph, beta, gamma, p0)
sim_tree <- SISsim(tree, beta, gamma, p0)

png(filename = "task1_plot.png", width = 10 * 100, height = 6 * 100, res = 100) 
ylim <- c(0, 1.0)
plot(sim_ER, type = "l", col = "red", xlab = "Time Steps", ylab = "Proportion Infected", main = "ER Network",  ylim = ylim)
lines(sim_BA, col = "blue")
lines(sim_WS, col = "green")
lines(sim_compl, col = "orange")
lines(sim_tree, col = "yellow")
legend("topright", legend = c("ER", "BA", "WS", "complete graph", "tree"), col = c("red", "blue", "green", "orange", "yellow"), lty = 1)
dev.off()
```

Falta a単adir las networks del paper en el plot (cuando las tengamos todas).
Y hacer el plot para cada una de las strategies.


SIS + vaccination strategy:

#Greedy strategy
```{r}
# Function to perform the greedy algorithm
greedy_algorithm <- function(G, b = round(0.1 * vcount(G)), max_walk_length = 10) {
  
  # Nested function for Monte Carlo simulation
  monte_carlo_simulation <- function(node, G, max_walk_length, num_simulations) {
    trap_count <- 0
    for (i in 1:num_simulations) {
      walk_length <- sample(1:max_walk_length, 1)
      end_node <- simulate_random_walk(node, G, walk_length)
      if (end_node == node) trap_count <- trap_count + 1
    }
    return(trap_count / num_simulations)
  }

  # Nested function to simulate a random walk from a node
  simulate_random_walk <- function(node, G, walk_length) {
    current <- node
    for (i in 1:walk_length) {
      neighbors <- neighbors(G, current)
      if (length(neighbors) == 0) break
      current <- sample(neighbors, 1)
    }
    return(current)
  }

  S <- vector("list", length = 0) # Set of nodes for traps
  node_benefits <- numeric(length = vcount(G)) # Store benefits for each node
  
  # Compute benefits for each node
  for (node in V(G)) {
    print(node)
    node_benefits[node] <- monte_carlo_simulation(node, G, max_walk_length, num_simulations = 100) #Set parameters
  }
  
  # Sort nodes by their benefits and select the top b nodes
  top_nodes <- order(node_benefits, decreasing = TRUE)
  S <- V(G)[top_nodes]

  return(S)
}
```

#Other strategies:

```{r}
# Function to calculate PageRank
calculate_pagerank <- function(G) {
  return(page_rank(G)$vector)
}

# Function to calculate P-pageRank
calculate_P_pagerank <- function(G, p) {
  return(page_rank(G, damping = p)$vector)
}

# Function to calculate Eigenvector Centrality
calculate_eigenvector_centrality <- function(G) {
  return(eigen_centrality(G)$vector)
}

# Function to calculate Betweenness Centrality
calculate_betweenness_centrality <- function(G) {
  return(betweenness(G))
}
```

SIS with vaccination strategy:

```{r}
# Extended SIS simulation function with vaccination strategy
SISsim_vaccination <- function(G, beta, gamma, vaccination_strategy,  p0, max_steps = 100, num_vaccinated = round(0.1 * vcount(G))) {
  
  num_vaccinated = round(0.1 * vcount(G))
  
  statuses <- numeric(vcount(G))
  statuses[sample(1:vcount(G), size = round(p0 * vcount(G)))] <- 1  # p0 fraction infected
  
  #Outputs
  prop_infected <- numeric(max_steps)
  num_infected <- numeric(max_steps)


  if(vaccination_strategy == "greedy"){
     vaccinated_nodes <- greedy_algorithm(G, num_vaccinated)
    
  } else {
    # Calculate vaccination scores based on the chosen strategy
    vaccination_scores <- switch(
      vaccination_strategy,
      "degree" = degree(G),
      "pagerank" = calculate_pagerank(G),
      "P_pagerank" = calculate_P_pagerank(G, p = 0.15),  # You can adjust the preference parameter
      "eigenvector" = calculate_eigenvector_centrality(G),
      "betweenness" = calculate_betweenness_centrality(G),
      "random" = runif(vcount(G)),  # Random vaccination
      "greedy" = greedy_algorithm(G, b = 0.1 * vcount(G))
    )
  
    # Sort nodes by vaccination score in descending order
    sorted_nodes <- order(-vaccination_scores)
  
    # Select a fraction of nodes for vaccination
    vaccinated_nodes <- sorted_nodes[1:round(0.1 * vcount(G))]
  }

  # Apply vaccination
  statuses[vaccinated_nodes] <- 0

  for (step in 1:max_steps) {
    for (node in 1:vcount(G)) {
      if (statuses[node] == 1) {
        neighbors <- neighbors(G, node)
        for (neighbor in neighbors) {
          # Get infected after contact (neighbors)
          if (statuses[neighbor] == 0 && runif(1) < beta) {
            statuses[neighbor] <- 1
          }
        }
        # Get recovered
        if (statuses[node] == 1 && runif(1) < gamma) {
          statuses[node] <- 0
        }
      }
    }
    
    num_infected[step] <- sum(statuses)
    prop_infected[step] <- sum(statuses) / vcount(G)
  }
  
  return(list(num_infected = num_infected, prop_infected = prop_infected[1:step]))
}
```


```{r}
vaccination_strategy <- "degree"

sim_vac_ER <- SISsim_vaccination(ER, beta, gamma, vaccination_strategy, p0)
sim_vac_BA <- SISsim_vaccination(BA, beta, gamma, vaccination_strategy, p0)
sim_vac_WS <- SISsim_vaccination(WS, beta, gamma, vaccination_strategy, p0)
sim_vac_compl <- SISsim_vaccination(complete_graph, beta, gamma, vaccination_strategy, p0)
sim_vac_tree <- SISsim_vaccination(tree, beta, gamma, vaccination_strategy, p0)

png(filename = "plots/task1_vac_plot.png", width = 10 * 100, height = 6 * 100, res = 100) 
ylim <- c(0, 1.0)
plot(sim_vac_ER, type = "l", col = "red", xlab = "Time Steps", ylab = "Proportion Infected", main = "ER Network")
lines(sim_vac_BA, col = "blue")
lines(sim_vac_WS, col = "green")
lines(sim_vac_compl, col = "orange")
lines(sim_vac_tree, col = "yellow")
legend("topright", legend = c("ER", "BA", "WS", "complete graph", "tree"), col = c("red", "blue", "green", "orange", "yellow"), lty = 1)
dev.off()
```

Falta a単adir las networks del paper en el plot (cuando las tengamos todas).
Y hacer el plot para cada una de las strategies.

#Plot of different strategies on networks.  (proportion of infected over time)
```{r}
networks <- c("ER", "BA", "WS", "complete_graph", "tree")
vaccination_strategies <- c("degree", "pagerank", "P_pagerank", "eigenvector", "betweenness", "random")


# Set up multiple plots in a grid
par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))

for (strategy in vaccination_strategies) {
  sim_result <- SISsim_vaccination(ER, beta, gamma, vaccination_strategy = strategy, p0)
  plot(sim_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Proportion Infected", main = paste("Vaccination Strategy in ER:", strategy))
} 

par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))
for (strategy in vaccination_strategies) {
  sim_result <- SISsim_vaccination(BA, beta, gamma, vaccination_strategy = strategy, p0)
  plot(sim_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Proportion Infected", main = paste("Vaccination Strategy in BA:", strategy))
} 

par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))
for (strategy in vaccination_strategies) {
  sim_result <- SISsim_vaccination(tree, WS, gamma, vaccination_strategy = strategy, p0)
  plot(sim_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Proportion Infected", main = paste("Vaccination Strategy in WS:", strategy))
} 

par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))
for (strategy in vaccination_strategies) {
  sim_result <- SISsim_vaccination(complete_graph, beta, gamma, vaccination_strategy = strategy, p0)
  plot(sim_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Proportion Infected", main = paste("Vaccination Strategy in complete_graph:", strategy))
} 

par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))
for (strategy in vaccination_strategies) {
  sim_result <- SISsim_vaccination(tree, beta, gamma, vaccination_strategy = strategy, p0)
  plot(sim_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Proportion Infected", main = paste("Vaccination Strategy in tree:", strategy))
} 

```

#Plot of the greedy strategy on a network (proportion of infected over time)
```{r}
vaccination_strategy <- "greedy"
sim_result <- SISsim_vaccination(ER, beta, gamma, vaccination_strategy, p0)

# Plot the results
plot(sim_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Proportion Infected", main = paste("SIS with Vaccination - ER Graph (", vaccination_strategy, ")"))
```


```{r}
# Function to run multiple SIS simulations and return the average number of infected individuals at each time step
average_SIS_simulations <- function(G, beta, gamma, vaccination_strategy, p0 = 0.05, max_steps = 100, num_simulations = 7, num_vaccinated = round(0.1 * vcount(G))) {
  avg_infected <- numeric(0)

  num_simulations<-7
  
  for (sim in 1:num_simulations) {
    
    res <- SISsim_vaccination(G, beta, gamma, vaccination_strategy, p0, max_steps, num_vaccinated)
    num_infected_result <- res$num_infected
    avg_infected <- avg_infected + num_infected_result
  }

  avg_infected <- avg_infected / num_simulations
  return(avg_infected)
}
```


```{r}
avg_infected_result <- average_SIS_simulations(ER, beta, gamma, vaccination_strategy, p0)

# Plot the results
plot(avg_infected_result, type = "l", col = "blue", xlab = "Time Steps", ylab = "Expected Number of Infected Individuals", main = paste("SIS with Vaccination - ER Graph (", vaccination_strategy, ")"))
```

```{r}
vaccination_strategy <- "degree"

avg_infected_result_RE <- average_SIS_simulations(ER, beta, gamma, vaccination_strategy, p0)
avg_infected_result_BA <- average_SIS_simulations(BA, beta, gamma, vaccination_strategy, p0)
avg_infected_result_WS <- average_SIS_simulations(WS, beta, gamma, vaccination_strategy, p0)
avg_infected_result_compl <- average_SIS_simulations(complete_graph, beta, gamma, vaccination_strategy, p0)
avg_infected_result_tree <- average_SIS_simulations(tree, beta, gamma, vaccination_strategy, p0)


png(filename = "avg_vac_plot.png", width = 10 * 100, height = 6 * 100, res = 100) 
ylim <- c(0, 1.0)
plot(avg_infected_result_RE, type = "l", col = "red", xlab = "Time Steps", ylab = "Expected Number of Infected Individuals", main = "ER Network")
lines(avg_infected_result_BA, col = "blue")
lines(avg_infected_result_WS, col = "green")
lines(avg_infected_result_compl, col = "orange")
lines(avg_infected_result_tree, col = "yellow")
legend("topright", legend = c("ER", "BA", "WS", "complete graph", "tree"), col = c("red", "blue", "green", "orange", "yellow"), lty = 1)
dev.off()
```

Falta a単adir las networks del paper en el plot (cuando las tengamos todas).
Y hacer el plot para cada una de las strategies.


Falta pero no me ha dado tiempo ahora:
Ejecutar los tres plots con colores. (falla el y_lim, a単adirlo)
Cambiar el nombre de la funcion sis_vac que calcula el expected en vez del proportion.
Cambiar que los plots se impriman aqui en vez de en un fichero.

Hacer plots del paper.


Simulations

```{r}

network_names <- c("ER", "BA", "WS", "complete_graph", "tree","GR_QC", "HEP_TH", "Facebook", "Deezer", "EmailEnron")
networks <- list(ER, BA, WS, complete_graph, tree,GR_QC,HEP_TH, Facebook, Deezer,EmailEnron)
vaccination_strategies <- c("degree", "pagerank", "P_pagerank", "eigenvector", "betweenness", "random", "greedy")

```


# Generate the selected vaccinated nodes

```{r}

get_vaccinated_nodes <- function(G, vaccination_strategy){
  if(vaccination_strategy == "greedy"){
     vaccinated_nodes <- greedy_algorithm(G, num_vaccinated)
    
  } else {
    # Calculate vaccination scores based on the chosen strategy
    vaccination_scores <- switch(
      vaccination_strategy,
      "degree" = degree(G),
      "pagerank" = calculate_pagerank(G),
      "P_pagerank" = calculate_P_pagerank(G, p = 0.15),  # You can adjust the preference parameter
      "eigenvector" = calculate_eigenvector_centrality(G),
      "betweenness" = calculate_betweenness_centrality(G),
      "random" = runif(vcount(G)),  # Random vaccination
      "greedy" = greedy_algorithm(G, b = 0.1 * vcount(G))
    )
  
    # Sort nodes by vaccination score in descending order
    sorted_nodes <- order(-vaccination_scores)
  
    # Select a fraction of nodes for vaccination
    vaccinated_nodes <- sorted_nodes[1:round(0.1 * vcount(G))]
  }
  return(vaccinated_nodes)
}

```


```{r}

for (i in 1:length(networks)) {
  G <- networks[[i]]
  network_name <- network_names[i]
  
  for (vaccination_strategy in vaccination_strategies) {
    vaccinated_nodes <- get_vaccinated_nodes(G, vaccination_strategy)
    node_ids <- as.numeric(V(G)[vaccinated_nodes])
    df <- data.frame(node_ids)
    filename <- paste("files/", network_name, "_", vaccination_strategy, ".csv", sep="")
    
    write.csv(df, file = filename, row.names = FALSE)
  }
}
```


SIS with vaccination strategy (using S):

```{r}
random_walk_infection <- function(G, start_node, L, statuses, S) {
    current_node <- start_node
    for (i in 1:L) {
        # Move to a random neighbor
        neighbors <- neighbors(G, current_node)
        if (length(neighbors) > 0) {
            current_node <- sample(neighbors, 1)
        }

        # Mark the current node as infected if it is not in S
        if (!current_node %in% S) {
            statuses[current_node] <- 1
        }
    }
    return(statuses)
}

simulate_crawlers <- function(G, S, L) {
    statuses <- rep(0, vcount(G))  # Initialize statuses to 0
    for (node in S) {
        statuses <- random_walk_infection(G, node, L, statuses, S)
    }
    return(statuses)
}

# Function to select set S from graph G
select_nodes <- function(G, S_size, case_type) {
  if (case_type == "case1") {
    # Random selection
    S <- sample(V(G), S_size)
  } else if (case_type == "case2") {
    # Targeted selection based on a criterion, e.g., highest degree
    degree_nodes <- order(-degree(G))
    S <- V(G)[degree_nodes[1:S_size]]
  }
  return(S)
}
```


```{r}
# Extended SIS simulation function with vaccination strategy
SISsim_vaccination <- function(G, beta, gamma, vacc_nodes_file,  L = 10, S_size = 10, max_steps = 100, num_vaccinated = round(0.1 * vcount(G)), case_type = "case1") {
  
  #Output initialization
  prop_infected <- numeric(max_steps)
  num_infected <- numeric(max_steps)
  
  # Choose S depending on the case being analyzed
  S <- select_nodes(G, S_size, case_type)
  statuses <- numeric(vcount(G))
  S_ids <- as.numeric(V(G)[S])
  
  # Infect the nodes
  for (node in S) {
        statuses <- random_walk_infection(G, node, L, statuses, S)
    }

  # Apply vaccination
  nodes_df <- read.csv(vacc_nodes_file, sep="\t", header=FALSE, skip=1)
  vaccinated_nodes <- nodes_df[, 1] 
  vaccinated_nodes<- na.omit(vaccinated_nodes[1:num_vaccinated])
  
  vaccinated_nodes<-setdiff(vaccinated_nodes, S_ids)
  
  statuses[vaccinated_nodes] <- 0
  
  statuses[vaccinated_nodes] <- 0

  for (step in 1:max_steps) {
    for (node in 1:vcount(G)) {
      if (statuses[node] == 1) {
        neighbors <- neighbors(G, node)
        for (neighbor in neighbors) {
          # Get infected after contact (neighbors)
          if (statuses[neighbor] == 0 && runif(1) < beta) {
            statuses[neighbor] <- 1
          }
        }
        # Get recovered
        if (statuses[node] == 1 && runif(1) < gamma) {
          statuses[node] <- 0
        }
      }
    }
    
    num_infected[step] <- sum(statuses)
    prop_infected[step] <- sum(statuses) / vcount(G)
  }
  
  return(list(num_infected = num_infected, prop_infected = prop_infected[1:step]))
}
```


```{r}

```




